#include "mian.h"

#define MAX_BUFFER_SIZE 1024

int main(void)
{
    char input[MAX_BUFFER_SIZE];

    if (fgets(input, sizeof(input), stdin) == NULL)
    {
        fprintf(stderr, "Failed to read input\n");
        return 1;
    }

    /* Remove the trailing newline character */
    input[strcspn(input, "\n")] = '\0';

    char *token;
    char **commands = malloc(MAX_BUFFER_SIZE * sizeof(char *));
    int command_count = 0;
    int fd[2];
    pid_t pid;
    int i = 0;
    char **args = malloc(MAX_BUFFER_SIZE * sizeof(char *));
    int arg_count = 0;

    // Split the input by pipe character '|'
    token = strtok(input, "|");
    while (token != NULL)
    {
        commands[command_count++] = strdup(token);
        token = strtok(NULL, "|");
    }
    commands[command_count] = NULL;
    
    while (commands[i] != NULL)
    {
        if (pipe(fd) == -1)
        {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        pid = fork();
        if (pid == -1)
        {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid == 0)
        {
            // Child process
            close(fd[0]); // Close unused read end

            // Set stdout to the write end of the pipe
            if (dup2(fd[1], STDOUT_FILENO) == -1)
            {
                perror("dup2");
                exit(EXIT_FAILURE);
            }

            // Split the command into arguments
            token = strtok(commands[i], " ");
            while (token != NULL)
            {
                args[arg_count++] = strdup(token);
                token = strtok(NULL, " ");
            }
            args[arg_count] = NULL;

            // Execute the command
            execute_command(args);

            // Free memory
            for (int j = 0; j < arg_count; j++)
            {
                free(args[j]);
            }
            free(args);

            exit(EXIT_SUCCESS);
        }
        else
        {
            // Parent process
            close(fd[1]); // Close unused write end

            // Set stdin to the read end of the pipe
            if (dup2(fd[0], STDIN_FILENO) == -1)
            {
                perror("dup2");
                exit(EXIT_FAILURE);
            }

            // Continue to the next command
            i++;
        }
    }

    // Free memory
    for (int j = 0; j < command_count; j++)
    {
        free(commands[j]);
    }
    free(commands);

    return 0;
}

